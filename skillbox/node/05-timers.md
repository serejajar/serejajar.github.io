Некоторые рекомендации:

Рекомендации по структуре кода:

- директория middlewares - здесь в каждом файле отдельно опишите нужные middlewares: для авторизации, для проверки авторизации и так далее

- директория routes - здесь в каждом файле опишите обработчики для апи: timers.js - апи для таймеров, auth.js - для авторизации (логин, регистрация и так далее)

- директория services - здесь будут функции для работы с данными. В этой директории добавьте директорию memory. Она будет отвечать за работу у с данными, которые просто хранятся в памяти. Далее мы ее расиширим, когда будем работать с базами данных. В ней реализуйте все необходимые функции: создание таймера, остановка, поиск и так далее. Эти функции должны использовать обработчики из routes.
- index.js - в этом файле Вы создаете объект приложения express, подключаете все нужные middlewares и routes и запускаете его

Во всех обработчиках таймеров нужно учитывать id текущего пользователя, т.е. пользователь должен получать только таймеры, которые он создал и останавливать только свои.

С уважением, Никита.
---
---
progress вам нужно будет высчитывать для того чтобы показать таймер на странице
    Вам нужно высчитать время старта, вот так:

    progress = текущее время в милесекундах - время старта;

-  res.render('index') для апи таймеров
Вам не нужно рендерить второй раз страницу. Используйте res.json вместо res.render.

###
Отклонить:
noauth
- сдают на проверку только первое задание
  Все работает по условиям ДЗ. Таймеры создаются и удаляются без ошибок. Ничего критичного в коде я не заметил. Отлично! Можете смело приступать к бонусному заданию.
  ---
    Будете делать доп. задание?

-
У вас этот рут должен возвращать активные или удаленные таймеры в зависимости от запроса:

/api/timers?isActive=false
/api/timers?isActive=true

-
Цифры таймера не меняются так как вы жестко указываете сам прогресс:


auth
- захеширован ли пароль

- таймеры видны другим
  Авторизация, регистрация, работа со счетчиками проходит по условия ДЗ. В целом вы все верно сделали, но есть одно маленькое, но очень важное исправление. Все таймеры одного пользователя не должны быть видны другому.
  ---
  Хоть это и не указанно в ТЗ, но это подразумевается. Если есть пользователь, значит у него есть данные которые скрыты для других пользователей.

###
Принять
По самому приложению, все выглядит отлично. Вам плюсик что разобрались с duration и progress! Можете приступать к бонусному заданию.
---
Регистрация и авторизация пользователя, добавление и удаление счетчиков проходит успешно. Все счетчики одного пользователя не видны другому. Отлично! ДЗ принято
---
Код написан неплохо, все работает как нужно хотя и не хватает routera-а, да и просто разбивки на файлы. Для меня это не критично, поэтому оставляю это на ваше усмотрение.


###
Похвалить
---
Авторизация, регистрация, работа со счетчиками проходит успешно. Но есть маленький нюанс который нужно исправить.
---
Вам плюсик за использование кодов сообщений от сервера.
---
В целом выглядит очень даже неплохо. Вам плюсик за хеширование пароля. Но есть нюанс который нужно исправить.



###
Рекомендации:
Хочу порекомендовать вам изучить документацию по router-у:
http://expressjs.com/en/5x/api.html#router
Хотя сейчас я не требую это, но в реальных проектах router используется очень активно.
---
Хочу порекомендовать также поизучать документацию к express.  У него есть неплохая русская документация.
https://expressjs.com/ru/
---
Можете так же глянуть в сторону nest.js, этот фреймворк начинают активно использовать:
https://ru.hexlet.io/blog/posts/gid-po-nest-js

###
Прочее

6. Express.js
- основная или бонусная часть
    Основная часть принята. Будете делать бонусную?

- регистрация
    При регистрации ничего не происходит. Тут нужен редирект на страницу с таймерами или хотя бы уведомить что регистрация прошла успешно.


- router
    В целом все верно, код хорошо написан, хотя и не используется router. Но есть маленькая ошибка которую нужно исправить:

    В целом все верно, код хорошо написан, есть разделение кода, но не используется router, хотя для этого приложения это не критично.




-----------------

Здесь нужно реализовать функции для обработки запросов со стороны клиента.

Первая обработчик для запроса GET /api/timers - он должен возвращать список активных/неактивных таймеров, в зависимости от переданного в query-параметрах параметра isActive

Второй запрос должен из req.body получать данные для создания нового таймера, создавать его и добавлять в массив TIMERS. Эта функция должна вернуть id созданного таймера.

----
Основная часть:

В целом все верно, код хорошо написан, есть разделение кода и используется router. Вам плюсик за использование кодов сообщений от сервера. Но есть маленькая ошибка которую нужно исправить:


-------------------
Проверить отправляет ли /api/timers/ активные/неактивные таймеры

Дублирующего кода не должно быть. Например, в /api/timers/ можно создать переменную isActive с самим условием и фильтровать таймеры по этому условию.

router.get("/", (req, res) => {
  if (req.query.isActive === "true") {
    DB.forEach((timer) => {
      if (!timer.isActive) return;
      timer.progress = Date.now() - timer.start;
    });

    res.json(DB.filter((timer) => timer.isActive));
    return;
  }

  res.json(DB.filter((timer) => !timer.isActive));
});

      router.get("/", (req, res) => {
        const isActive = req.query.isActive === "true";

        if (isActive) {
          /* здесь ваш код */
        }

        /* отправка ответа только один раз */
        res.json(DB.filter((timer) => timer.isActive === isActive));

      });

      Примерно так. Но я написал этот код и подумал что уже к мелочам придираюсь)))

------------------
В router.post("/:id/stop") не совсем понятно зачем добавлен этот код в блок catch :

router.post("/:id/stop", (req, res) => {
    DB.forEach((timer) => {
      if (timer.id !== req.params.id) return;

      timer.end = Date.now();
      timer.isActive = false;
      timer.duration = timer.end - timer.start;
      delete timer.progress;
    });

    res.status(204).json(DB);
});
---
Т.е. при создании таймера вы сохраняете само время создания и при запросе активных таймеров высчитываете разницу между временем старта и текущим. Разница между между ними это и есть progress

При удалении таймера, нужно сохранить время удаления и высчитать разницу временем между старта и конца. Это и есть duration.
