
progress вам нужно будет высчитывать для того чтобы показать таймер на странице
    Вам нужно высчитать время старта, вот так:

    progress = текущее время в милесекундах - время старта;

-  res.render('index') для апи таймеров
Вам не нужно рендерить второй раз страницу. Используйте res.json вместо res.render.

###
Отклонить:
# сдают на проверку только первое задание

Все работает по условиям ДЗ. Таймеры создаются и удаляются без ошибок. Ничего критичного в коде я не заметил. Отлично!


-
У вас этот рут должен возвращать активные или удаленные таймеры в зависимости от запроса:

/api/timers?isActive=false
/api/timers?isActive=true

-
Цифры таймера не меняются так как вы жестко указываете сам прогресс:


auth
- захеширован ли пароль

# таймеры видны другим
Авторизация, регистрация, работа со счетчиками проходит по условия ДЗ. В целом вы все верно сделали, но есть одно маленькое, но очень важное исправление. Все таймеры одного пользователя не должны быть видны другому.
---
Хоть это и не указанно в ТЗ, но это подразумевается. Если есть пользователь, значит у него есть данные которые скрыты для других пользователей.

# таймеры равны NaN:NaN
По самому приложению, все выглядит неплохо, но сейчас таймеры  на странице равны NaN:NaN.

Так происходит когда не высчитано свойство progress для таймера. Вот пример кода для понимания как высчитывать progress:

app.get("/api/timers", (req, res) => {
  if (req.query.isActive === "true") {
    DB.forEach((timer) => {
      if (!timer.isActive) return;
      timer.progress = Date.now() - timer.start;
    });

    res.json(DB.filter((timer) => timer.isActive));
    return;
  }

  res.json(DB.filter((timer) => !timer.isActive));
});


Исправьте это и я приму вашу работу.

###
Принять
Все работает по условиям ДЗ. Таймеры создаются и удаляются без ошибок. Ничего критичного в коде я не заметил. Отлично!
---
По самому приложению, все выглядит отлично. Вам плюсик что разобрались с duration и progress! Можете приступать к бонусному заданию.
---
Регистрация и авторизация пользователя, добавление и удаление счетчиков проходит успешно. Все счетчики одного пользователя не видны другому. Отлично! ДЗ принято
---
Код написан неплохо, все работает как нужно хотя и не хватает routera-а, да и просто разбивки на файлы. Для меня это не критично, поэтому оставляю это на ваше усмотрение.
----
По следующему модулю:

То же самое задание, только теперь данные храним в базе данных postgresql. Просто копируйте текущий код и нужно будет дописать новый функционал, об этом ниже.

- Параметры подключения к бд нужно передавать при запуске через переменные окружения, используя например dotenv https://www.npmjs.com/package/dotenv

Т.е. Вы заводите файл .env-sample где указываете все нужные переменные для запуска сервера, и создаете свой локальный файл .env в котором уже указываете нужные значения. Не забудьте создать файл .env-sample, и предоставьте, пожалуйста, доступы к вашей базе данных, я так смогу быстрее проверить задание.

- Если будете создавать свою бд в таких сервисах как, например https://www.elephantsql.com обратите внимание, что у Вас будет ограничение на одновременные подключения к бд, вроде не больше 3, поэтому тут нужно использовать пул соединений: https://knexjs.org/guide/#pool

- Для названия колонок в бд используйте camelCase, чтобы не надо было маппить user_id -> userId. Для обращения к колонкам в camelCase в postgres их нужно заключать в скобки:

select "userId" from timer
- Часто нужно получить одну строку из бд, но knex по-умолчанию всегда возвращает массив и студенты делают так:

const oneRow = knex().select().limit(1).then(results => results[0])
limit(1).then(...) можно заменить на https://knexjs.org/guide/query-builder.html#first

###
Похвалить
---
Авторизация, регистрация, работа со счетчиками проходит успешно. Но есть маленький нюанс который нужно исправить.
---
Вам плюсик за использование кодов сообщений от сервера.
---
В целом выглядит очень даже неплохо. Вам плюсик за хеширование пароля. Но есть нюанс который нужно исправить.



###
Рекомендации:
Хочу порекомендовать вам изучить документацию по router-у:
http://expressjs.com/en/5x/api.html#router
Хотя сейчас я не требую это, но в реальных проектах router используется очень активно.
---
Хочу порекомендовать также поизучать документацию к express.  У него есть неплохая русская документация.
https://expressjs.com/ru/
---
Можете так же глянуть в сторону nest.js, этот фреймворк начинают активно использовать:
https://ru.hexlet.io/blog/posts/gid-po-nest-js

###
Прочее

6. Express.js
- основная или бонусная часть
    Основная часть принята. Будете делать бонусную?

- регистрация
    При регистрации ничего не происходит. Тут нужен редирект на страницу с таймерами или хотя бы уведомить что регистрация прошла успешно.


- router
    В целом все верно, код хорошо написан, хотя и не используется router. Но есть маленькая ошибка которую нужно исправить:

    В целом все верно, код хорошо написан, есть разделение кода, но не используется router, хотя для этого приложения это не критично.




-----------------

Здесь нужно реализовать функции для обработки запросов со стороны клиента.

Первая обработчик для запроса GET /api/timers - он должен возвращать список активных/неактивных таймеров, в зависимости от переданного в query-параметрах параметра isActive

Второй запрос должен из req.body получать данные для создания нового таймера, создавать его и добавлять в массив TIMERS. Эта функция должна вернуть id созданного таймера.

----
Основная часть:

В целом все верно, код хорошо написан, есть разделение кода и используется router. Вам плюсик за использование кодов сообщений от сервера. Но есть маленькая ошибка которую нужно исправить:


-------------------
Проверить отправляет ли /api/timers/ активные/неактивные таймеры

Дублирующего кода не должно быть. Например, в /api/timers/ можно создать переменную isActive с самим условием и фильтровать таймеры по этому условию.

router.get("/", (req, res) => {
  if (req.query.isActive === "true") {
    DB.forEach((timer) => {
      if (!timer.isActive) return;
      timer.progress = Date.now() - timer.start;
    });

    res.json(DB.filter((timer) => timer.isActive));
    return;
  }

  res.json(DB.filter((timer) => !timer.isActive));
});

      router.get("/", (req, res) => {
        const isActive = req.query.isActive === "true";

        if (isActive) {
          /* здесь ваш код */
        }

        /* отправка ответа только один раз */
        res.json(DB.filter((timer) => timer.isActive === isActive));

      });

      Примерно так. Но я написал этот код и подумал что уже к мелочам придираюсь)))

------------------
В router.post("/:id/stop") не совсем понятно зачем добавлен этот код в блок catch :

router.post("/:id/stop", (req, res) => {
    DB.forEach((timer) => {
      if (timer.id !== req.params.id) return;

      timer.end = Date.now();
      timer.isActive = false;
      timer.duration = timer.end - timer.start;
      delete timer.progress;
    });

    res.status(204).json(DB);
});
---
Т.е. при создании таймера вы сохраняете само время создания и при запросе активных таймеров высчитываете разницу между временем старта и текущим. Разница между между ними это и есть progress

При удалении таймера, нужно сохранить время удаления и высчитать разницу временем между старта и конца. Это и есть duration.
