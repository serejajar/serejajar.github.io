###
Отклонить:
Основное задание:
- process.exit(1) вместо кода
    Как минимум нужно вместо console.error(код); нужно использовать process.exit(код).
    ---
    Сейчас ваш скрипт заканчивает работу с неправильным кодом, вам нужно это исправить. Если нет файла, то нужно выйти с process.exit(100). Для файла хеша соответственно нужно использовать process.exit(101). Если хеши не совпадают, программа должна вывести сообщение об ошибке и выйти с кодом process.exit(102).


- не срабатывает для jpg файлов основного задания
  Осталось исправить проверку картинок, Данная команда должна сработать без ошибок:
  Вы можете проверить работу своего скрипта используя  файлы в папке test-files

    Вроде все верно, но пару нюансов упустили. Я пока напишу что нужно исправить для того чтобы сравнение локальных файлов работало, а затем перейдем к логике доп. задания. Сейчас вы получаете содержимое хеш-файла в бинарном ввиде. Тут вам нужно добавить кодировку при считывании файла c хешем. Но только для файла хеша.

- Харкодят путь к файлу
  Вы верно поняли задачу, кроме одного нюанса. Вы проверяете только одни файл test.txt, а ваш скрипт должен работать с любым файлом переданным ему в качестве аргумента.
  ---  
  Указать сам путь к этому файлу. Например:

  node index.js test-files/LICENSE

  Ваш скрипт должен получить путь к любому файлу. Т.е. он должен без ошибок сработать с таким путем (если этот файл есть)

  node index.js ../../test.txt

- неверный хеш
  Так же проверьте с помощью вашего скрипта изображения. При сравнивании хешей для картинок (например cat.jpg и др.) выдает ошибку неверного хеша, хотя он верный. Можете запустить тесты с помощью команды npm test для быстрой проверки скрипта.

- ошибки в тестах
  В целом подход верный, но ваш скрипт не всегда срабатывает корректно. Вы можете это проверить с помощью тестовых файлов из папки ./test-files. Это надо исправить.
  ---
  Проверьте, пожалуйста, ваш скрипт с тестовыми файлами из папки ./test-files. Скрипт не всегда срабатывает корректно. Это надо исправить.

- Бонус?
  Будете делать бонусное задание или я могу принять работу?

Бонусное задние:
- не срабатывает для jpg файлов
  Попробуйте добавить в запрос для файлов следующую опцию:
  axios.get(filePath, { responseType: 'arraybuffer'}

###
Принять
Отлично! Все тесты для проходят успешно. Вам плюсик за то что самостоятельно разобрались с задачей
---
Отлично! Все тесты для основного и бонусного задания проходят успешно. Вам плюсик за то что самостоятельно разобрались с задачами.

###
Похвалить
Вам плюсик, за то что вы правильно используете методы для считывания файлов. Но есть несколько исправлений.
---
Вам плюсик что самостоятельно разобрались с задачей и в частности с axios для картинок! ДЗ принято.
---
Но я не буду придираться и оставлю это исправление на ваше усмотрение. Будете делать бонусное задание или я могу принять работу?


###
Рекомендовать:

В качестве доп. материала к изучению рекомендую вам изучить часто используемую библиотеку axios. В частности ее можно использовать для бонусного задания.
https://github.com/axios/axios
---
В качестве доп. материала к изучению рекомендую вам изучить часто используемую библиотеку node-fetch
https://github.com/node-fetch/node-fetch

###
Прочее
- trim()


- будет ли делать бонусное задание.
    Будете делать дополнительное задание или я могу принять работу?



----------
Тесты для основного задания выполняются, а вот тесты для бонусной имеют ошибки. Хотите исправить или сдать только основную часть?

-----------------
Получить и сохранить в переменную содержимое файла (readFile или readFileSync). Проверить значение этой переменной и, в случае ошибки, выйти из скрипта с помощью кода 100.

--------------

Получите точно также файл .sha256, но в этом случае код ошибки будет 101.
---------------

Создайте хеш с помощью библиотеки crypto.


-------------------
БОНУС:
-------------------
Нужно убрать console.error(err), так как это способствует убеждению пользователя  о поломке в ходе использования скрипта. Код "100" нам даст достаточно информации, чтобы понять об ошибке чтения файла.

Не используйте переменные объявленные через var. Вы должны про них знать, так как скорее всего будете поддерживать старый код, но var устарел и его не нужно использовать в заданиях.

-------------------


Запросы к файлам в интернете всегда асинхронны.

Один из вариантов решения бонусной части - выполнить оба запроса одновременно с помощью Promise.all. И после получения файлов сравнить их.

    Это хороший вопрос)) Да вы правы, логика скрипта должна быть такой. Ну а Promise.all в плане конструкции чуть проще, поэтому я ее рекомендую в самом начале если возникают трудности с реализацией. И мне нравится что вы стараетесь проникнуть в суть работы скрипта)))

-------------------

Можно создать логику скрипта для бонусной части так, что бы работа скрипта "замораживалась" пока не отработает сам запрос. Это можно сделать с помощью конструкции async/await:

async function fetchFileFromNet(url) {
  const file = await yourAsyncFn(url);

  return file;
}

      Должно быть так:
      1) В async функции вы создаете логику для запроса к переменную.
      2) Вызываете async функцию и сохраняете результат в переменную.
      3) Делаете то же самое для файла хеша
      4) Создаете и сравниваете хеши


            Примерно вот так:

            async function fetchFileFromNet(url) {
              const file = await fetch(url);

              return file;
            }

            const file = fetchFileFromNet(url);



Насколько я вижу все остальные тесты проходят без ошибок. Проверьте, пожалуйста, получен ли был хеш для указанных вами файлов.


---------------------
Отлично! Вы добавили синхронную функцию fs.readFileSync. Теперь нужно считать оба файла подобным способом. Так же вам нужно проверить есть ли данные файлы. Если нет самого файла, то нужно выйти с process.exit(100). Для файла хеша соответственно нужно использовать process.exit(101)

Протестировать отсутствие  .sha256 файла  можно с помощью такого аргумента в вашей команде.

node index ./test-files/cat-lonely.jpg
Сейчас ваше приложение падает со следующей ошибкой:


Напишите если будет нужна моя помощь с получением и проверкой файлов.


Проверил вашу работу. В целом подход верный, но сейчас скрипт неправильно работает с файлами с коректным хешем, как с локальными, так и из сети. Вот пример локального файла:

Для этих файлов присутствует соответствующий файл с корректным хешем, но ваш скрипт пишет обратное. Напишите, пожалуйста, если нужна будет помощь с этой задачей.
---
# Решение 1
import fs from "fs";
import crypto from 'crypto';

let file = null;

try {
  file = fs.readFileSync(process.argv[2]);
} catch (e) {
  process.exit(100);
}

const hash = crypto.createHash("sha256").update(file).digest("hex");
const sha256 = `${process.argv[2]}.sha256`;

let fileSha256 = null;

try {
  fileSha256 = fs.readFileSync(sha256, "utf8");
} catch (e) {
  process.exit(101);
}

console.log('hash = ', hash);
console.log('fileSha256 = ', fileSha256);

if (hash !== fileSha256.trim()) {
  process.exit(102);
} else {
  process.exit(0);
}

# Решение 2
const fs = require('fs');
const crypto = require('crypto');
const file = process.argv[2];
const shaFile = `${file}.sha256`;

fs.readFile(file, (err, data) => {
  if (err) process.exit(100);
  const hash = crypto.createHash('sha256').update(data).digest('hex');
  fs.readFile(shaFile, 'utf8', (err, data) => {
    if (err) process.exit(101);
    if (hash != data.trim()) process.exit(102);
    else console.log(data);
  });
});
