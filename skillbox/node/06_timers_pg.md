
Никита Куцелай
28 декабря 2022 г. 09:45

Добрый день, Михаил!

Оставил небольшой совет https://gitlab.skillbox.ru/mikhail_shmagin/node/-/merge_requests/3

Можете его реализовать в следующем модуле

По следующему модулю:

Тоже самое задание, только теперь данные храним в базе данных postgresql. Просто копируйте текущий код и нужно будет дописать новый функционал, об этом ниже.

1. Файлы миграций храните в директории migrations

2. В package.json добавьте скрипт, который бы запускал миграции

3. Параметры подключения к бд нужно передавать при запуске через переменные окружения, используя например dotenv https://www.npmjs.com/package/dotenv

Т.е. Вы заводите файл  .env.example где указываете все нужные переменные для запуска сервера, и создаете свой локальный файл .env в котором уже указываете нужные значения. Файл .env не должен попасть в репозиторий на gitlab, т.е. не должен отслеживаться git. Когда я скачаю Ваш репозиторий, я скопирую .env.example в .env, укажу свои нужные значения и запущу сервис

4. Если будете создавать свою бд в таких сервисах как например elephant https://www.elephantsql.com/ обратите внимание, что у Вас будет ограничение на одновременные подключения к бд, вроде не больше 3, поэтому тут нужно использовать пул соединений: https://knexjs.org/guide/#pool

5.  Для названия колонок используйте в бд используйте camelCase, чтобы не надо было маппить user_id -> userId. Для обращения к колонкам в camelCase в postgres их нужно заключать в скобки:

select "userId" from timer

6. Часто нужно получить одну строку из бд, но knex по-умолчанию всегда возвращает массив и студенты делают так:

const oneRow = knex().select().limit(1).then(results => results[0])

limit(1).then(...) можно заменить на https://knexjs.org/guide/query-builder.html#first

7. По файловой структуре: создайте директорию services/memory, перенесите туда функции, которые работаю с данными из памяти, так же создайте директорию services/pg в ней реализуйте точно такие же методы для работы с данными, как в модуле с хранением в памяти, в этой же директории создайте файл в котором будет создаваться экземпляр knex для подключения к бд. Заведите переменную окружения в .env.example, которая будет отвечать какой способ хранения использовать: в памяти или бд:

STORAGE=memory  или STORAGE=pg

и в services/index.js реализуйте загрузку нужных функций:

const services = require(`./${STORAGE}.js`);
module.exports = services;

С уважением, Никита.

###
отклонить:
- проверить предоставлены ли доступы к базе.
    Не забудьте создать файл .env-sample, и предоставьте, пожалуйста, доступы к вашей базе данных, я так смогу быстрее проверить задание.

    Предоставьте, пожалуйста, доступы к вашей базе данных из файла .env, я так смогу быстрее проверить задание.

- нет рутера
    Задание проверил, отличная работа.
    Все выполнено в соответствии с заданием. Не хватает использования express router, но это не критично для данного задания.
- проверить сохраниние прогресса в БД
Поле progress хранить в базе не нужно, его можно вычислять для каждого полученного активного таймера.

Каждый раз обновлять его в бд неоптимально
- knex.raw("progress + 1000")
    Код выше сразу дает несколько проблем.

    1. Прогрес для таймера добавиться только если будет этот запрос за таймерами. Т.е. если пользователь ушел со страницы, его таймеры не будут обновляться.

    2. Прогресс сохраняется напрямую в базу. В реальных проектах хотелось бы такого избежать по причине минимизации запросов к базе.  Тут можно поменять логику получения прогресса для таймеров чтобы прогрес высчитывался исходя из текущей даты и времени старта.

- проверить в коде остановку уже остановленного таймера

- захеширован ли пароль


###
Принять
Все выполнено в соответствии с заданием. Вам плюсик за разбивку кода на небольшие части, использование express router и классы.
---
Задание проверил, отличная работа.
Все выполнено в соответствии с заданием. Не хватает разбивки кода на небольшие части, использования express router, но это не критично для данного задания.

###
Похвалить
Вам плюсик за обработку случаев с неверным id/остановленным таймером.
---
Все работает по условиям ДЗ. Вы верно подключили базу данных и настроили миграции.
---
Вам плюсик за то что вы не сохраняете прогресс таймера в базу, а высчитываете его в руте.

###
Порекомендовать:
Хочу вам порекомендовать для дополнительного изучения, вот этот учебник по SQL. В нем можно найти много интересного для себя
https://www.w3schools.com/sql/default.asp
---
UIID

###
Прочее

7. Базы данных, Реляционные ДБ


Вы уже перенесли код для таймеров. Отлично, часть работы уже сделана!

Вы можете начать с добавления рутов для аутентификации. Вначале вы можете не использовать данные из базы, а добавить их уже на следующем шаге.

----------
router.post("/login", async (req, res) => {
  const { username, password } = req.body;

  const user = await findUserByUsername(username);

  if (!user || hash(password) !== user?.password) {
    const params = new URLSearchParams("");
    params.append("authError", "true");
    return res.status(400).redirect(`/?${params.toString()}`);
  }

  const sessionId = await createSession(user.id);

  res.cookie("sessionId", sessionId, { httpOnly: true }).status(200).redirect("/");
});

router.get("/logout", async (req, res) => {
  await deleteSession(req.cookies["sessionId"]);
  res.status(204).clearCookie("sessionId").redirect("/");
});




Отлично! Вы добавили код для аутентификации!

Следующим шагом будет добавление хеша и разделение кода на части.
Помните задание из 03_hash? Логика та же)) Выведите часть кода отвечающая за создание хеша в функцию, которая будет храниться в отдельном файле. То же самое сделайте с рутами для аутентификации и таймерами используя router.

    Логика простая: пользователь вводит пароль в форме на сайте и crypto его преобразует в набор случайных символов, которые трудно запомнить и трудно взломать, и сравнивает с точно таким же хешем пароля из базы.

    Здесь пароль введенный пользователем сравнивается с паролем из базы. Тут вам нужно заменить переменную с паролем на переменную содержащую хеш пароля.

    Отлично! Теперь используйте хеш пароля при сравнении паролей в руте /login.

------------------
router.post("/signup", async (req, res) => {
  const { username, password } = req.body;

  const user = await findUserByUsername(username);

  if (user) {
    const params = new URLSearchParams("");
    params.append("authError", encodeURI(`Username ${username} is exsist, please login`));
    return res.status(400).redirect(`/?${params.toString()}`);
  }

  const [id] = await db("users")
    .insert({ username, password: hash(password) })
    .returning("id");

  const sessionId = await createSession(id);

  res.cookie("sessionId", sessionId, { httpOnly: true }).status(201).redirect("/");
});


Все верно! Следующим шагом нужно сделать логику регистрации /signup, но теперь из введенного пароля нужно создать хеш, который будет и записан в базу вместо самого пароля.

    Код верный, только не забудьте что вы в руте /signup сохраняете в базу сам пароль, а не хеш. Создайте его на основе пароля и сохраните хеш в базе и мы перейдем к следующему шагу.

        Knex.insert() сохраняет нового пользователя. В параметры этой функции и нужно передать хешированный пароль.

    Теперь нужно добавить в /signup проверку существует ли пользователь с таким логином перед добавлением нового. Проверка такая же как и в /login.

    На следующем шаге, нужно получить id созданого пользователя и создать для него сессию.

        Вы можете вернуть id нового пользователя и создать ему сессию в /signup с редиректом на главную страницу. Код такой же как и в /login.

            Верните id с помощью returning и сохраните его в переменной, которую можно использовать в создании сессии. https://knexjs.org/#Builder-returning


            Отлично! Теперь у вас есть аутентификация. Осталась мелочь, добавить коды ответа при успешной (или нет) работе рута. Выглядит это так:
            res.cookie("sessionId", sessionId, { httpOnly: true }).status(201).redirect("/");
            Для ошибки аутентификации соответственно нужно возвращать код 400. Так же добавьте коды http ответов для рута /login

    А теперь выведите повторяющийся код для создания хеша в отдельную функцию. Поместите эту функцию в отдельный файл и экспортируйте его в index.js

--------------
У вас есть массив TIMERS с данными таймеров. Вам нужно создать таблицу для таймеров, где вы будете хранить те же самые значения, что и в этом объекте.

--------------

Нужно создать таблицу для таймеров, а потом добавить возможность связать таймер(ы) с определенным пользователем.

--------------

#Не работает база данных#

А что находится в базе данных в данной таблице?

-------

Проверьте, пожалуйста, подключение к базе данных. Для этого вам нужно добавить следующий код ниже конфигурации knex.

const { Client } = require("pg");

(async () => {
   await client.connect();
   try {
     const res = await client.query("SELECT * FROM users");
     console.log(res.rows);
   } catch (err) {
     console.error(err);
   }
   client.end();
})();

--------

Не забудьте создать файл .env-sample, и предоставьте, пожалуйста, доступы к вашей базе данных, я так смогу быстрее проверить задание.

Предоставьте, пожалуйста, доступы к вашей базе данных из файла .env, я так смогу быстрее проверить задание.
--------

При регистрации нового пользователя, вы можете произвести поиск по его логину в базе. Если пользователь найден, то выдать ошибку регистрации.


-------
